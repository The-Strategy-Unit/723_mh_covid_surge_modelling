#' Combined Plot
#'
#' Generates a plot that shows the actual demand data, along with the suppressed activty figures, and the model output.
#'
#' @param model_output output from \code{run_model()} and \code{get_model_output()}
#' @param treatment a name of a treatment to filter by
#' @param params the current `params` object used to model the data
#'
#' @return a plotly chart
#'
#' @import rlang
#' @importFrom plotly plot_ly layout config
#' @importFrom dplyr %>% filter group_by summarise across mutate rename
#' @importFrom tidyr pivot_longer
#' @importFrom lubridate ymd
combined_plot <- function(model_output, treatment, params) {
  df <- bind_rows(
    models %>%
      get_model_output() %>%
      filter(.data$treatment == {{treatment}},
             .data$type == "treatment") %>%
      group_by(.data$date) %>%
      summarise(across(.data$value, sum), .groups = "drop") %>%
      mutate(type = "surge"),

    params$demand[[treatment]] %>%
      pivot_longer(-.data$month, names_to = "type") %>%
      rename(date = .data$month) %>%
      mutate(across(.data$date, ymd))
  )

  bind_rows(
    df,
    df %>%
      filter(day(date) == 1) %>%
      group_by(.data$date) %>%
      summarise(across(.data$value, sum), type = "total")
  ) %>%
    plot_ly(type = "scatter",
            mode = "lines",
            x = ~date,
            y = ~value,
            color = ~type) %>%
    layout(showlegend = TRUE,
           xaxis = list(title = "Month"),
           yaxis = list(title = "# Referrals")) %>%
    config(displayModeBar = FALSE)
}

#' Referrals Plot
#'
#' Generates a plot that shows the referrals generated by the model.
#'
#' @param model_output output from \code{run_model()} and \code{get_model_output()}
#' @param treatment a name of a treatment to filter by
#'
#' @return a plotly chart
#'
#' @importFrom dplyr %>% filter group_by summarise across
#' @import rlang
#' @importFrom plotly plot_ly layout config
referrals_plot <- function(model_output, treatment) {
  df <- model_output %>%
    filter(.data$type == "new-referral",
           .data$treatment == {{treatment}}) %>%
    group_by(.data$date) %>%
    summarise(across(.data$value, sum), .groups = "drop")

  if (nrow(df) < 1) return(NULL)

  plot_ly(df,
          type = "scatter",
          mode = "lines",
          x = ~date,
          y = ~value,
          hovertext = NULL,
          hovertemplate = paste("<b>Month</b>: %{x}",
                                "<b>Referrals</b>: %{y:.0f}",
                                "<extra></extra>",
                                sep = "<br>")) %>%
    layout(showlegend = FALSE,
           xaxis = list(title = "Month"),
           yaxis = list(title = "New Referrals")) %>%
    config(displayModeBar = FALSE)
}

#' Demand Plot
#'
#' Generates a plot that shows the demand generated by the model.
#'
#' @param model_output output from \code{run_model()} and \code{get_model_output()}
#' @param appointments output from \code{get_appointments()}
#' @param treatment a name of a treatment to filter by
#'
#' @return a plotly chart
#'
#' @importFrom dplyr %>% filter group_by summarise across inner_join mutate
#' @import rlang
#' @importFrom plotly plot_ly layout config
demand_plot <- function(model_output, appointments, treatment) {
  df <- model_output %>%
    filter(.data$type == "treatment",
           .data$treatment == {{treatment}}) %>%
    group_by(.data$date, .data$treatment) %>%
    summarise(across(.data$value, sum), .groups = "drop") %>%
    inner_join(appointments, by = "treatment") %>%
    mutate(no_appointments = .data$value * .data$average_monthly_appointments)

  if (nrow(df) < 1) return(NULL)

  plot_ly(df,
          type = "scatter",
          mode = "lines",
          x = ~date,
          y = ~no_appointments,
          hovertemplate = paste("<b>Month</b>: %{x}",
                                "<b>Demand</b>: %{y:.0f}",
                                "<extra></extra>",
                                sep = "<br>")) %>%
    layout(showlegend = FALSE,
           xaxis = list(title = "Month"),
           yaxis = list(title = "Demand")) %>%
    config(displayModeBar = FALSE)
}

#' Population Groups Plot
#'
#' Generates a plot that shows the size of the population groups for a given treatment.
#'
#' @param model_output output from \code{run_model()} and \code{get_model_output()}
#' @param treatment a name of a treatment to filter by
#'
#' @return a plotly chart
#'
#' @importFrom dplyr %>% filter group_by summarise across inner_join mutate
#' @importFrom forcats fct_reorder fct_relabel
#' @import rlang
popgroups_plot <- function(model_output, treatment) {
  df <- model_output %>%
    filter(.data$type == "new-referral",
           .data$treatment == {{treatment}},
           day(.data$date) == 1) %>%
    group_by(.data$group) %>%
    summarise(`# Referrals` = round(sum(.data$value), 0), .groups = "drop") %>%
    filter(.data$`# Referrals` != 0) %>%
    mutate(across(.data$group, fct_reorder, .data$`# Referrals`))

  plot_ly(df,
          x = ~`# Referrals`,
          y = ~group,
          text = df$`# Referrals`,
          textposition = "auto",
          type = "bar",
          marker = list(color = "rgb(158,202,225)",
                        line = list(color = "rgb(8,48,107)", width = 1.5))) %>%
    layout(xaxis = list(title = "# Referrals"),
           yaxis = list(title = "")) %>%
    config(displayModeBar = FALSE)
}

#' Surge Plot
#'
#' Generates a plot that shows the amount of people who were referred and treated, and referred but not treated, as
#' generated by the model.
#'
#' @param data output from \code{surge_summary()}
#'
#' @return a plotly chart
#'
#' @importFrom dplyr %>% mutate across rename
#' @importFrom tidyr pivot_longer
#' @importFrom forcats fct_rev
#' @importFrom plotly layout config add_trace
surge_plot <- function(data) {
  df <- data %>%
    mutate(across(.data$`new-referral`, ~.x - .data$`new-treatment`)) %>%
    rename("Received treatment" = .data$`new-treatment`,
           "Referred, but not treated" = .data$`new-referral`)

  plot_ly(df,
          x = ~`Received treatment`,
          y = ~group,
          text = paste0("<b>Received treatment</b><br>",
                        comma(df[["Received treatment"]])),
          hoverinfo = "text",
          type = "bar",
          name = "Received treatment") %>%
    add_trace(x = ~df[["Referred, but not treated"]],
              name = "Referred, but not treated",
              text = paste0("<b>Referred, but not treated</b><br>",
                            comma(df[["Referred, but not treated"]]))) %>%
    layout(xaxis = list(title = "Total Referrals / Treatments"),
           yaxis = list(title = ""),
           barmode = "stack",
           legend = list(xanchor = "right",
                         yanchor = "bottom",
                         x = 0.99,
                         y = 0.01)) %>%
    config(displayModeBar = FALSE)
}

#' Create Graph
#'
#' Generates a network graph of the flows from population groups, to conditions, to treatments, as generated by the
#' model.
#'
#' @param model_output output from \code{run_model()} and \code{get_model_output()}
#' @param groups a vector of population groups to include in the graph, defaults to all groups
#' @param conditions a vector of conditions to include in the graph, defaults to all conditions
#' @param treatments a vector of treatments to include in the graph, defaults to all treatments
#'
#' @return a plotly chart
#'
#' @import rlang
#' @importFrom dplyr %>% filter group_by summarise across bind_rows
#' @importFrom tidyr pivot_longer
#' @importFrom purrr set_names compose map array_tree
#' @importFrom lubridate day
#' @importFrom igraph graph_from_data_frame vertex.attributes
#'   vertex.attributes<- V get.edgelist layout.sugiyama
#' @importFrom plotly plot_ly layout config
create_graph <- function(model_output,
                         groups = unique(model_output$group),
                         conditions = unique(model_output$condition),
                         treatments = unique(model_output$treatment)) {
  df <- model_output %>%
    filter(.data$type == "treatment",
           .data$group %in% groups,
           .data$condition %in% conditions,
           .data$treatment %in% treatments,
           day(.data$date) == 1) %>%
    group_by(.data$group, .data$condition, .data$treatment) %>%
    summarise(across(.data$value, compose(round, sum)), .groups = "drop")

  if (nrow(df) < 1) return(NULL)

  # create a graph of groups to conditions and conditions to the treatment
  # note however, this graph is "reversed", e.g. treatment points to conditions
  # the layout didn't work otherwise.
  g <- bind_rows(
    df %>% group_by(from = .data$condition, to = .data$group),
    df %>% group_by(from = .data$treatment, to = .data$condition)
  ) %>%
    summarise(weight = sum(.data$value), .groups = "drop") %>%
    # remove any lines that after rounding sum to 0
    filter(.data$weight > 0) %>%
    graph_from_data_frame()

  # converts the graph to be a bipartite graph
  vertex.attributes(g)$type <- vertex.attributes(g)$name %in% unique(df$condition)

  # calculate the "weight" of each vertex
  vertex_weights <- df %>%
    pivot_longer(-.data$value, names_to = "type", values_to = "name") %>%
    group_by(.data$type, .data$name) %>%
    summarise(across(.data$value, sum), .groups = "drop")
  # convert to a named list: add in the current treatment as an option also
  vertex_weights <- set_names(vertex_weights$value, vertex_weights$name)

  # set the "weight" attribute of this vertex
  vertex.attributes(g)$weight <- vertex_weights[vertex.attributes(g)$name]

  # extract the vertices
  vs <- V(g)
  # and the edges
  es <- as.data.frame(get.edgelist(g))
  # create a layout for the graph ready to plot
  ly <- layout.sugiyama(g)$layout

  # extract the x- and y-coordinates from the layout
  xs <- ly[, 2]
  ys <- ly[, 1]

  p <- plot_ly(x = ~ xs,
               y = ~ ys,
               size = 1,
               mode = "markers",
               type = "scatter",
               text = paste0("<b>", vs$name, "</b>: ", round(vs$weight)),
               marker = list(
                 opacity = 1,
                 # set the size of each marker to be based on the amount of
                 # people in this group.
                 # take the weight of each vertex and divide by the total size,
                 # so this will convert into the range [0, 1]
                 # take the sqrt of this to make a non-linear increase in size
                 # - this makes smaller dots bigger than they should be
                 # multiply by 500 to make the dots visible (size in pixels?)
                 # ceiling it to turn into an integer
                 size = ceiling(sqrt(unname(vs$weight)) / sqrt(sum(df$value)) * 500)
               ),
               # NHS Blue
               color = I("#005EB8"),
               hoverinfo = "text")

  # iterate over all of the edges and build a shape for each edge: e.g. a line
  # connecting each pair of vertices
  edge_shapes <- map(array_tree(es), function(e) {
    # get the first and second vertex
    v0 <- which(vs$name == e$V1)
    v1 <- which(vs$name == e$V2)

    # create the points
    list(
      type = "line",
      line = list(color = "#030303", width = 1),
      # ensure th
      layer = "below",
      x0 = xs[v0],
      y0 = ys[v0],
      x1 = xs[v1],
      y1 = ys[v1]
    )
  })

  # render the plot, adding the edges
  layout(p,
         shapes = edge_shapes,
         xaxis = list(visible = FALSE),
         yaxis = list(visible = FALSE)) %>%
    config(displayModeBar = FALSE)
}


#' Treemap plot
#'
#' Creates a treemap of the population group sizes at baseline.
#'
#' @param params the current `params` object used to model the data
#'
#' @return a plotly chart
#'
#' @importFrom purrr map_dbl
#' @importFrom dplyr %>% left_join tribble mutate group_by summarise across bind_rows transmute
#' @importFrom tidyr fill
#' @import rlang
#' @importFrom plotly plot_ly config
treemap_plot <- function(params) {
  subpopn_to_level_2 <- tribble(
    ~subpopn,                         ~level_2,
    "Children & young people",        "Children & young people",
    "Students FE & HE",               NA,
    "Elderly alone",                  "Elderly alone",
    "General population",             "General population",
    "Domestic abuse victims",         "Other Adults and Specific Groups",
    "Family of COVID deceased",       NA,
    "Family of ICU survivors",        NA,
    "Newly unemployed",               NA,
    "Pregnant & New Mothers",         NA,
    "Parents",                        NA,
    "Health and care workers",        "Directly affected individuals",
    "ICU survivors",                  NA,
    "Learning disabilities & autism", "Existing Conditions",
    "Pre existing CMH illness",       NA,
    "Pre existing LTC",               NA,
    "Pre existing SMI",               NA
  ) %>%
    fill(.data$level_2) %>%
    # plotly treemap needs to have unique names between these levels
    mutate(across(.data$level_2, ~paste0("'", .x, "'")))

  params$groups %>%
    map_dbl("size") %>%
    (function(population_group_sizes) {
      tibble(
        subpopn = names(population_group_sizes),
        value = unname(population_group_sizes)
      )
    })() %>%
    left_join(subpopn_to_level_2, by = "subpopn") %>%
    (function(.x) {
      bind_rows(
        .x %>%
          mutate(label = .data$level_2) %>%
          group_by(.data$label) %>%
          summarise(across(.data$value, sum), parent = "", .groups = "drop"),
        transmute(.x, label = .data$subpopn, parent = .data$level_2, .data$value)
      )
    })() %>%
    group_by(parent) %>%
    filter(dplyr::n() > 1) %>%
    plot_ly(labels = ~label,
            parents = ~parent,
            values = ~value,
            type = "treemap") %>%
    config(displayModeBar = FALSE)
}

#' Subpopulation curve plot
#'
#' displays a quick plot of what the current parameters selected for the subpopulation group will generate
#'
#' @param curve the curve vector to display
#' @param size the base population size
#' @param pcnt the percentage of the base population size we are using (0 - 100)
#'
#' @importFrom plotly plot_ly layout config
#'
#' @return a plotly chart
subpopulation_curve_plot <- function(curve, size, pcnt) {
  x <- seq_along(curve)
  y <- curve * size * pcnt / 100

  plot_ly(x = x,
          y = y,
          type = "scatter",
          mode = "lines",
          text = paste0("month ", x, ": ", comma(y)),
          hoverinfo = "text",
          line = list(shape = "spline")) %>%
    layout(xaxis = list(visible = FALSE,
                        showgrid = FALSE,
                        zeroline = FALSE),
           yaxis = list(visible = FALSE),
           margin = list(l = 0, r = 0, b = 0, t = 0, pad = 1),
           showlegend  = FALSE) %>%
    config(displayModeBar = FALSE)
}

#' Treatment split plot
#'
#' generates a bar chart to show the percentage splits for the current treatments
#'
#' @param treatments a named vector of the splits for the treatments
#'
#' @importFrom dplyr tibble mutate across arrange desc
#' @importFrom forcats fct_reorder
#' @importFrom plotly plot_ly layout config
#' @import rlang
#'
#' @return a plotly chart
treatment_split_plot <- function(treatments) {
  tibble(treatment = names(treatments),
         split = treatments) %>%
    mutate(across(.data$split, ~ .x / sum(.x)),
           across(.data$treatment, fct_reorder, split)) %>%
    arrange(desc(.data$split)) %>%
    plot_ly(x = ~split,
            y = ~treatment,
            type =  "bar") %>%
    layout(xaxis = list(tickformat = "%",
                        title = FALSE),
           yaxis = list(title = FALSE))  %>%
    config(displayModeBar = FALSE)
}
